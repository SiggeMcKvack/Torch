================================================================================
TORCH CODEBASE PERFORMANCE AUDIT - EXECUTIVE SUMMARY
================================================================================

Analysis conducted: Very thorough exploration of all specified areas
Total findings: 25+ optimization opportunities across 5 categories

================================================================================
KEY FILES ANALYZED
================================================================================

PRIMARY BOTTLENECKS:
1. /home/user/Torch/src/Companion.cpp (1761 lines)
   - Main processing loop
   - Asset parsing and management
   - Data structure operations
   
2. /home/user/Torch/src/utils/Decompressor.cpp (228 lines)
   - ROM decompression caching
   - Memory management issues
   
3. /home/user/Torch/src/factories/DisplayListFactory.cpp (648 lines)
   - Asset processing with table searches
   - String building operations
   
4. /home/user/Torch/src/factories/GenericArrayFactory.cpp (499 lines)
   - Array processing and formatting
   - Multiple iterations over data

SUPPORTING ANALYSIS:
5. /home/user/Torch/src/archive/SWrapper.cpp & ZWrapper.cpp
   - Archive creation and compression
   
6. /home/user/Torch/src/utils/StringHelper.cpp
   - String operations utility functions
   
7. /home/user/Torch/src/Companion.h
   - Data structure definitions
   - Complex nested containers

================================================================================
TOP 10 PERFORMANCE RECOMMENDATIONS
================================================================================

PRIORITY 1 - HIGH IMPACT, LOW EFFORT:
───────────────────────────────────
1. SearchTable() Linear Search → Binary Search
   Location: /home/user/Torch/src/Companion.cpp:1491-1499
   Issue: O(n) search called frequently during asset processing
   Fix: Use std::lower_bound on sorted gTables vector
   Expected Improvement: 10-50% depending on table count
   
2. String Concatenation → ostringstream
   Location: /home/user/Torch/src/Companion.cpp:529-530, 536-537
   Issue: File headers built with repeated += operations
   Fix: Use std::ostringstream for efficient buffering
   Expected Improvement: 5-15% in file generation
   
3. Regex Compilation → Static Compilation
   Location: /home/user/Torch/src/Companion.cpp:343
   Issue: Regex compiled every iteration in ParseEnums()
   Fix: Compile regex once as static member
   Expected Improvement: 20-40% in enum parsing

4. Vector Copies → Move Semantics
   Location: /home/user/Torch/src/Companion.cpp:935
   Issue: WriteEntry objects copied repeatedly
   Fix: Use std::move for write entries
   Expected Improvement: 10-20% in code export phase


PRIORITY 2 - HIGH IMPACT, MEDIUM EFFORT:
──────────────────────────────────────
5. GetNodesByType() Full Iteration → Index Cache
   Location: /home/user/Torch/src/Companion.cpp:1647-1668
   Issue: O(n) iteration + repeated YAML parsing
   Fix: Build type index during node parsing
   Expected Improvement: 30-60% for type lookups
   
6. std::find() → unordered_set
   Location: Multiple - /home/user/Torch/src/factories/naudio/v0/AudioManager.cpp:246, 557
   Issue: Linear searches in loops (O(n²) algorithms)
   Fix: Use unordered_set for membership checking
   Expected Improvement: 25-50% in audio processing
   
7. Decompressor Manual Memory → Smart Pointers
   Location: /home/user/Torch/src/utils/Decompressor.cpp:14-75
   Issue: Manual new/delete, unbounded cache, no safety
   Fix: Use std::unique_ptr with LRU cache policy
   Expected Improvement: Memory safety + bounded growth
   
8. File Read Duplication → Caching
   Location: /home/user/Torch/src/Companion.cpp:600-602, 722
   Issue: YAML files read multiple times per processing
   Fix: Implement file content cache
   Expected Improvement: 20-40% I/O reduction


PRIORITY 3 - MEDIUM IMPACT:
─────────────────────────
9. Missing const References
   Location: Multiple function signatures across codebase
   Issue: Unnecessary copies of strings, vectors, nodes
   Fix: Audit and add const references to 50+ functions
   Expected Improvement: 5-10% overall
   
10. YAML Parsing Caching
    Location: /home/user/Torch/src/Companion.cpp:722, 1092, 1367
    Issue: Redundant YAML::LoadFile calls
    Fix: Cache parsed YAML nodes by path
    Expected Improvement: 15-30% YAML overhead reduction


================================================================================
ALGORITHMIC BOTTLENECKS IDENTIFIED
================================================================================

O(n²) ALGORITHMS:
─────────────
- std::find() in loops for deduplication (Companion.cpp:1260)
- Audio envelope/sample duplicate checking (AudioManager.cpp)
  IMPACT: High for large audio libraries

O(n) SEARCHES CALLED O(m) TIMES:
──────────────────────────────
- SearchTable() called per asset (1491-1499)
- GetNodesByType() called per factory (1647-1668)
  IMPACT: 20-50 calls per file × table/type count

O(n) STRING OPERATIONS:
─────────────────────
- StringHelper::Replace() rescans from beginning each iteration
- Regex patterns compiled per line
- YAML node parsing repeated
  IMPACT: 5-20% of parsing time


================================================================================
MEMORY INEFFICIENCIES
================================================================================

UNBOUNDED CACHE:
───────────────
gCachedChunks in Decompressor.cpp grows without limits
- Can consume gigabytes for large projects
- No cache eviction policy
- Potential memory leaks on exceptions

TEMPORARY ALLOCATIONS:
────────────────────
- String concatenation creates temporaries
- Vector copies in write operations
- YAML node copies in GetNodesByType()
  POTENTIAL PEAK: 50-100MB+ temporary allocations

NESTED CONTAINERS:
─────────────────
std::unordered_map<std::string, std::unordered_map<uint32_t, 
    std::tuple<std::string, YAML::Node>>> gAddrMap
- String hashing overhead
- Tuple unpacking in lookups
- Cache-unfriendly access patterns


================================================================================
I/O PERFORMANCE ISSUES
================================================================================

MULTIPLE READS:
───────────────
- YAML files read multiple times (hash calc + parsing)
- Directory traversal repeated in Process() and Pack()
- ROM data read into memory without buffering

ARCHIVE COMPRESSION:
───────────────────
- Files compressed individually (no batching)
- No compression level tuning
- Vector copies in archive operations (SWrapper.cpp, ZWrapper.cpp)


================================================================================
PRIORITY IMPLEMENTATION ORDER
================================================================================

PHASE 1 (Quick Wins - 1-2 days):
  1. SearchTable() binary search
  2. String concatenation → ostringstream  
  3. Regex static compilation
  4. Vector move semantics in writes

PHASE 2 (Medium Term - 1 week):
  5. GetNodesByType() index caching
  6. std::find() → unordered_set replacements
  7. Decompressor smart pointers + LRU cache
  8. File read caching implementation

PHASE 3 (Longer Term - 2-3 weeks):
  9. const reference audit across codebase
  10. YAML parsing cache implementation
  11. Batch processing optimizations
  12. Container restructuring (AddressEntry struct)


================================================================================
EXPECTED OVERALL IMPROVEMENTS
================================================================================

TIMING:
  - Phase 1: 15-25% overall improvement
  - Phase 2: Additional 20-30% improvement
  - Phase 3: Additional 10-15% improvement
  TOTAL POTENTIAL: 45-70% overall speedup

MEMORY:
  - Unbounded cache fix: 50-70% reduction in cache memory
  - String/vector optimizations: 20-30% reduction in peak usage
  - TOTAL POTENTIAL: 30-50% peak memory reduction

I/O OPERATIONS:
  - File caching: 20-40% fewer disk reads
  - Binary search: O(n) → O(log n) searches
  - TOTAL POTENTIAL: 15-30% I/O reduction


================================================================================
TESTING STRATEGY
================================================================================

MICRO-BENCHMARKS:
  - SearchTable before/after optimization
  - String operations performance
  - Vector copy overhead measurement

REGRESSION TESTING:
  - Total processing time tracking
  - Memory usage monitoring (peak and sustained)
  - File I/O count logging
  - Cache hit rate statistics

PROFILING TOOLS:
  - Linux: perf, valgrind
  - Windows: VTune, Windows Performance Analyzer
  - Portable: gperftools

TARGET METRICS:
  - Process time reduction
  - Memory peak reduction
  - Cache miss rates
  - CPU cycle efficiency


================================================================================
DETAILED RECOMMENDATIONS IN AUDIT DOCUMENT
================================================================================

See companion file: performance_audit.md

Full analysis includes:
- Code examples with before/after
- Complexity analysis
- Specific line numbers and context
- Estimated impact per change
- Implementation guidance

